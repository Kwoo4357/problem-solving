## 이분 탐색
다음과 같은 조건을 가정
- 데이터가 정렬되어 있음
- 임의의 K가 데이터에 속해있다는 것을 알고 있음

위와 같은 조건에서 K가 어느 위치(인덱스)에 있을지 빠른 시간(O(logN)) 내에 알아낼 수 있다.  
방법은 계속 가운데 값을 K와 비교해서 다를 경우 그 왼쪽 구간이나 오른쪽 구간에서 다시 찾는 것  
간단한 코드로 나타냈을 때 다음과 같다.
```python
data = [i for i in range(1001)]
left, right = 0, 1000 # 데이터의 처음부터 주어진 데이터 크기만큼 설정
K = int(input())

while left <= right:
    mid = (left-right)//2
    # 가운데가 K보다 크면 왼쪽 범위에서, 작으면 오른쪽 범위에서 다시 찾음
    left, right = (left, mid-1) if data[mid]>=K else (mid+1, right) 
```
물론 위 코드 예시에서는 i번째 index에 i라는 값이 있을 거라는걸 알고 있지만, 이걸 모르고 있는 상황이라고 가정.  
범위를 계속 반으로 줄여나가기 때문에 데이터 크기의 log 값에 비례하는 시간 복잡도를 가진다.  

데이터가 비교적 균등하게 퍼져있을거라고 기대하는 경우 기준을 가운데로 잡지 않고 임의의 위치로 잡을 수도 있는데, K 값이 left에 가깝다면 left에 가깝게, right에 가깝다면 right에 가깝게 기준을 설정하는 방식이다.